{
    order realip first
    order rate_limit after realip
    order coraza_waf after rate_limit
}

:{$PORT} {
    log {
        output stdout
        format json
        level INFO
    }

    respond /health 200
    
    # Smart compression - exclude binary content
    encode gzip zstd {
        match {
            header Content-Type text/*
            header Content-Type application/json*
            header Content-Type application/javascript*
            header Content-Type application/xml*
            header Content-Type application/x-www-form-urlencoded*
        }
    }

    realip {
        header X-Forwarded-For
        header X-Real-IP
        header CF-Connecting-IP
        from   100.64.0.0/10
    }

    # === SMART MATCHERS ===
    
    # Detect streaming/range requests
    @streaming {
        header Range *
    }
    
    # Detect large uploads
    @large_upload {
        header Content-Length >10485760  # > 10MB
    }
    
    # WebSocket detection
    @websocket {
        header Connection *upgrade*
        header Upgrade websocket
    }
    
    # Requests that should go through WAF
    @waf_eligible {
        not header Connection *upgrade*
        not header Upgrade websocket
        not header Range *
        not header Content-Length >209715200  # Not larger than WAF limit
        not method OPTIONS
    }

    # === SMART RATE LIMITING ===
    rate_limit {
        # Lenient limits for streaming/downloads
        zone streaming {
            key    {remote_host}
            match  header Range *
            events 1000
            window 1m
        }
        
        # Lenient limits for large uploads
        zone uploads {
            key    {remote_host}
            match  header Content-Length >1048576
            events 100
            window 1m
        }
        
        # Strict limits for potential auth endpoints (generic detection)
        zone auth_like {
            key    {remote_host}
            match {
                method POST
                header Content-Type application/json*
                header Content-Length <1024
            }
            events 10
            window 1m
        }
        
        # General limits
        zone general {
            key    {remote_host}
            events 300
            window 1m
        }
    }

    # === SECURITY HEADERS ===
    header {
        Strict-Transport-Security "max-age=31536000; includeSubDomains; preload"
        Content-Security-Policy "upgrade-insecure-requests"
        Referrer-Policy "no-referrer"
        Permissions-Policy "interest-cohort=()"
        X-Content-Type-Options "nosniff"
        X-Frame-Options "SAMEORIGIN"
        X-XSS-Protection "1; mode=block"
        Cache-Control "no-cache, no-store, must-revalidate"
        -Server
        -X-Powered-By
    }

    # === WAF Configuration (only for eligible requests) ===
    coraza_waf @waf_eligible {
        load_owasp_crs
        
        directives `
            Include @coraza.conf-recommended
            Include @crs-setup.conf.example
            
            SecRuleEngine On
            SecRequestBodyAccess On
            SecResponseBodyAccess Off
            
            # === REQUEST BODY LIMITS ===
            # Maximum request body size: 200MB (allows large file uploads)
            SecRequestBodyLimit 209715200
            SecRequestBodyLimitAction Reject
            
            # Maximum request body size for non-file uploads: 1MB (forms, JSON, etc.)
            SecRequestBodyNoFilesLimit 1048576
            
            # Moderate paranoia level
            SecAction "id:900000,phase:1,nolog,pass,t:none,setvar:tx.paranoia_level=1"
            SecAction "id:900001,phase:1,nolog,pass,t:none,setvar:tx.blocking_paranoia_level=1"
            
            # Allow common HTTP methods
            SecAction "id:900010,phase:1,nolog,pass,t:none,setvar:tx.allowed_methods=GET HEAD POST OPTIONS PUT PATCH DELETE"
            
            # Your specified content types
            SecAction "id:900200,phase:1,nolog,pass,t:none,setvar:tx.allowed_request_content_type=|application/x-www-form-urlencoded| |multipart/form-data| |multipart/related| |text/xml| |application/xml| |application/soap+xml| |application/json| |application/cloudevents+json| |application/cloudevents-batch+json| |text/plain| |application/octet-stream| |image/jpeg| |image/png| |image/gif| |image/webp| |video/mp4| |video/avi| |video/mov| |video/quicktime| |video/x-msvideo|"
            
            # Anomaly scoring
            SecAction "id:900110,phase:1,nolog,pass,t:none,setvar:tx.inbound_anomaly_score_threshold=10"
            SecAction "id:900111,phase:1,nolog,pass,t:none,setvar:tx.critical_anomaly_score=5"
            
            # Logging
            SecAuditEngine RelevantOnly
            SecAuditLogParts ABCDEFGHIJKZ
            SecAuditLog /dev/stdout
            SecAuditLogFormat json
            SecAuditLogType Serial
            SecAuditLogRelevantStatus "^(?:5|4[01][0-9])"
            SecDebugLog /dev/stderr
            SecDebugLogLevel 1
            
            # Performance tuning
            SecArgumentsLimit 1000
            SecCookieFormat 0
            
            Include @owasp_crs/*.conf
        `
    }

    # === REVERSE PROXY with adaptive configuration ===
    
    # Handle streaming/range requests with optimized settings
    handle @streaming {
        reverse_proxy {env.BACKEND} {
            header_up Host {http.reverse_proxy.upstream.hostport}
            header_up X-Real-IP {remote_host}
            header_up X-Forwarded-Proto https
            header_up X-Forwarded-Scheme https
            
            transport http {
                dial_timeout 60s
                dial_fallback_delay 300ms
                response_header_timeout 60s
                keepalive_idle_conns 10
                keepalive_idle_conns_per_host 2
                max_conns_per_host 0
                compression off
            }
            
            # Critical for streaming
            flush_interval -1
        }
    }
    
    # Handle large uploads with appropriate timeouts
    handle @large_upload {
        reverse_proxy {env.BACKEND} {
            header_up Host {http.reverse_proxy.upstream.hostport}
            header_up X-Real-IP {remote_host}
            header_up X-Forwarded-Proto https
            header_up X-Forwarded-Scheme https
            
            transport http {
                dial_timeout 30s
                response_header_timeout 30s
                keepalive_idle_conns 10
                keepalive_idle_conns_per_host 2
            }
            
            flush_interval 100ms
        }
    }
    
    # Handle WebSocket connections
    handle @websocket {
        reverse_proxy {env.BACKEND} {
            header_up Host {http.reverse_proxy.upstream.hostport}
            header_up X-Real-IP {remote_host}
            
            transport http {
                dial_timeout 10s
                keepalive_idle_conns 10
                keepalive_idle_conns_per_host 2
            }
        }
    }
    
    # Default handler for everything else
    handle {
        reverse_proxy {env.BACKEND} {
            header_up Host {http.reverse_proxy.upstream.hostport}
            header_up X-Real-IP {remote_host}
            header_up X-Forwarded-Proto https
            header_up X-Forwarded-Scheme https
            
            transport http {
                dial_timeout 5s
                dial_fallback_delay 300ms
                response_header_timeout 10s
                keepalive_idle_conns 100
                keepalive_idle_conns_per_host 10
                max_conns_per_host 0
                compression off
            }
            
            health_uri /health
            health_interval 10s
            health_timeout 5s
            
            lb_policy round_robin
            lb_try_duration 30s
            lb_try_interval 250ms
            
            fail_duration 10s
        }
    }

    # === ERROR HANDLING ===
    handle_errors {
        # Suppress common streaming errors
        @streaming_errors {
            expression {http.error.status_text} == "broken pipe" || {http.error.status_text} == "stream error" || {http.error.status_text} == "context canceled"
        }
        
        @rate_limit expression {http.error.status_code} == 429
        @forbidden expression {http.error.status_code} == 403
        @server_error expression {http.error.status_code} >= 500
        
        # Return 200 for expected streaming interruptions
        respond @streaming_errors 200
        
        respond @rate_limit "Too Many Requests - Please slow down" 429
        respond @forbidden "Access Denied" 403
        respond @server_error "Service Temporarily Unavailable" 503
    }
}
